(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{389:function(t,e,o){"use strict";o.r(e);var r=o(45),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h3",{attrs:{id:"nodejs-commonjs与es6-import区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-commonjs与es6-import区别"}},[t._v("#")]),t._v(" NodeJs commonJs与ES6 import区别")]),t._v(" "),o("p",[o("a",{attrs:{href:"https://segmentfault.com/a/1190000039346572",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://segmentfault.com/a/1190000039346572"),o("OutboundLink")],1)]),t._v(" "),o("p",[o("a",{attrs:{href:"https://juejin.cn/post/6844904067651600391",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://juejin.cn/post/6844904067651600391"),o("OutboundLink")],1)]),t._v(" "),o("p",[t._v("1、CommonJS require是同步加载方案，ES6 import是异步加载方案。")]),t._v(" "),o("p",[t._v("2、CommonJS 模块输出的是一个值的拷贝（深拷贝），ES6 模块输出的是值的引用（浅拷贝）")]),t._v(" "),o("p",[t._v("3、CommonJS模块是运行时加载，而ES6 模块是编译时输出接口，使得对JS的模块进行静态分析成为了可能；")]),t._v(" "),o("h3",{attrs:{id:"为什么不在浏览器也是用commonjs"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#为什么不在浏览器也是用commonjs"}},[t._v("#")]),t._v(" 为什么不在浏览器也是用CommonJS")]),t._v(" "),o("p",[t._v("回答这个问题之前，我们首先要清楚一个事实，CommonJS的 "),o("code",[t._v("require")]),t._v(" 语法是同步的，当我们使用"),o("code",[t._v("require")]),t._v(" 加载一个模块的时候，必须要等这个模块加载完后，才会执行后面的代码。如果知道这个事实，那我们的问题也就很容易回答了。"),o("strong",[t._v("NodeJS")]),t._v(" 是服务端，使用 "),o("code",[t._v("require")]),t._v(" 语法加载模块，一般是一个文件，只需要从本地硬盘中读取文件，它的速度是比较快的。但是在浏览器端就不一样了，文件一般存放在服务器或者CDN上，如果使用同步的方式加载一个模块还需要由网络来决定快慢，可能时间会很长，这样浏览器很容易进入“假死状态”。所以才有了后面的"),o("strong",[t._v("AMD")]),t._v("和"),o("strong",[t._v("CMD")]),t._v("模块化方案，它们都是异步加载的，比较适合在浏览器端使用。")])])}),[],!1,null,null,null);e.default=n.exports}}]);