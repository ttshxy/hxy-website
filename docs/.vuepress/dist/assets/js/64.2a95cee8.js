(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{430:function(e,t,n){"use strict";n.r(t);var r=n(45),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"代码分割"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码分割"}},[e._v("#")]),e._v(" 代码分割")]),e._v(" "),n("h2",{attrs:{id:"打包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#打包"}},[e._v("#")]),e._v(" 打包")]),e._v(" "),n("p",[e._v("大多数 React 应用都会使用 "),n("a",{attrs:{href:"https://webpack.docschina.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack"),n("OutboundLink")],1),e._v("，"),n("a",{attrs:{href:"https://rollupjs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rollup"),n("OutboundLink")],1),e._v(" 或 "),n("a",{attrs:{href:"http://browserify.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Browserify"),n("OutboundLink")],1),e._v(" 这类的构建工具来打包文件。打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”。接着在页面上引入该 bundle，整个应用即可一次性加载。")]),e._v(" "),n("h4",{attrs:{id:"示例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[e._v("#")]),e._v(" 示例")]),e._v(" "),n("p",[n("strong",[e._v("App文件：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// app.js\nimport { add } from './math.js';\n\nconsole.log(add(16, 26)); // 42\n// math.js\nexport function add(a, b) {\n  return a + b;\n}\n")])])]),n("p",[n("strong",[e._v("打包后文件：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function add(a, b) {\n  return a + b;\n}\n\nconsole.log(add(16, 26)); // 42\n")])])]),n("blockquote",[n("p",[e._v("注意：")]),e._v(" "),n("p",[e._v("最终你打包后的文件可能看起来会和上面的例子区别很大。")])]),e._v(" "),n("p",[e._v("如果你正在使用 "),n("a",{attrs:{href:"https://create-react-app.dev/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Create React App"),n("OutboundLink")],1),e._v("，"),n("a",{attrs:{href:"https://nextjs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Next.js"),n("OutboundLink")],1),e._v("，"),n("a",{attrs:{href:"https://www.gatsbyjs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Gatsby"),n("OutboundLink")],1),e._v("，或者类似的工具，你可以直接使用内置的 Webpack 配置来构建你的应用。")]),e._v(" "),n("p",[e._v("如果你没有使用这类工具，你就需要自己来进行配置。例如，查看 Webpack 文档上的"),n("a",{attrs:{href:"https://webpack.docschina.org/guides/installation/",target:"_blank",rel:"noopener noreferrer"}},[e._v("安装"),n("OutboundLink")],1),e._v("和"),n("a",{attrs:{href:"https://webpack.docschina.org/guides/getting-started/",target:"_blank",rel:"noopener noreferrer"}},[e._v("入门教程"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("h2",{attrs:{id:"代码分割-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码分割-2"}},[e._v("#")]),e._v(" 代码分割")]),e._v(" "),n("p",[e._v("打包是个非常棒的技术，但随着你的应用增长，你的代码包也将随之增长。尤其是在整合了体积巨大的第三方库的情况下。你需要关注你代码包中所包含的代码，以避免因体积过大而导致加载时间过长。")]),e._v(" "),n("p",[e._v("为了避免搞出大体积的代码包，在前期就思考该问题并对代码包进行分割是个不错的选择。 代码分割是由诸如 "),n("a",{attrs:{href:"https://webpack.docschina.org/guides/code-splitting/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack"),n("OutboundLink")],1),e._v("，"),n("a",{attrs:{href:"https://rollupjs.org/guide/en/#code-splitting",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rollup"),n("OutboundLink")],1),e._v(" 和 Browserify（"),n("a",{attrs:{href:"https://github.com/browserify/factor-bundle",target:"_blank",rel:"noopener noreferrer"}},[e._v("factor-bundle"),n("OutboundLink")],1),e._v("）这类打包器支持的一项技术，能够创建多个包并在运行时动态加载。")]),e._v(" "),n("p",[e._v("对你的应用进行代码分割能够帮助你“懒加载”当前用户所需要的内容，能够显著地提高你的应用性能。尽管并没有减少应用整体的代码体积，但你可以避免加载用户永远不需要的代码，并在初始加载的时候减少所需加载的代码量。")]),e._v(" "),n("h2",{attrs:{id:"import"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#import"}},[e._v("#")]),e._v(" "),n("code",[e._v("import()")])]),e._v(" "),n("p",[e._v("在你的应用中引入代码分割的最佳方式是通过动态 "),n("code",[e._v("import()")]),e._v(" 语法。")]),e._v(" "),n("p",[n("strong",[e._v("使用之前：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import { add } from './math';\n\nconsole.log(add(16, 26));\n")])])]),n("p",[n("strong",[e._v("使用之后：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import("./math").then(math => {\n  console.log(math.add(16, 26));\n});\n')])])]),n("p",[e._v("当 Webpack 解析到该语法时，会自动进行代码分割。如果你使用 Create React App，该功能已开箱即用，你可以"),n("a",{attrs:{href:"https://create-react-app.dev/docs/code-splitting/",target:"_blank",rel:"noopener noreferrer"}},[e._v("立刻使用"),n("OutboundLink")],1),e._v("该特性。"),n("a",{attrs:{href:"https://nextjs.org/docs/advanced-features/dynamic-import",target:"_blank",rel:"noopener noreferrer"}},[e._v("Next.js"),n("OutboundLink")],1),e._v(" 也已支持该特性而无需进行配置。")]),e._v(" "),n("p",[e._v("如果你自己配置 Webpack，你可能要阅读下 Webpack 关于"),n("a",{attrs:{href:"https://webpack.docschina.org/guides/code-splitting/",target:"_blank",rel:"noopener noreferrer"}},[e._v("代码分割"),n("OutboundLink")],1),e._v("的指南。你的 Webpack 配置应该"),n("a",{attrs:{href:"https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269",target:"_blank",rel:"noopener noreferrer"}},[e._v("类似于此"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("p",[e._v("当使用 "),n("a",{attrs:{href:"https://babeljs.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babel"),n("OutboundLink")],1),e._v(" 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。对于这一要求你需要 "),n("a",{attrs:{href:"https://classic.yarnpkg.com/en/package/@babel/plugin-syntax-dynamic-import",target:"_blank",rel:"noopener noreferrer"}},[e._v("@babel/plugin-syntax-dynamic-import"),n("OutboundLink")],1),e._v(" 插件。")]),e._v(" "),n("h2",{attrs:{id:"react-lazy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-lazy"}},[e._v("#")]),e._v(" "),n("code",[e._v("React.lazy")])]),e._v(" "),n("p",[n("code",[e._v("React.lazy")]),e._v(" 函数能让你像渲染常规组件一样处理动态引入（的组件）。")]),e._v(" "),n("p",[n("strong",[e._v("使用之前：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import OtherComponent from './OtherComponent';\n")])])]),n("p",[n("strong",[e._v("使用之后：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const OtherComponent = React.lazy(() => import('./OtherComponent'));\n")])])]),n("p",[e._v("此代码将会在组件首次渲染时，自动导入包含 "),n("code",[e._v("OtherComponent")]),e._v(" 组件的包。")]),e._v(" "),n("p",[n("code",[e._v("React.lazy")]),e._v(" 接受一个函数，这个函数需要动态调用 "),n("code",[e._v("import()")]),e._v("。它必须返回一个 "),n("code",[e._v("Promise")]),e._v("，该 Promise 需要 resolve 一个 "),n("code",[e._v("default")]),e._v(" export 的 React 组件。")]),e._v(" "),n("p",[e._v("然后应在 "),n("code",[e._v("Suspense")]),e._v(" 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { Suspense } from 'react';\n\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <OtherComponent />\n      </Suspense>\n    </div>\n  );\n}\n")])])]),n("p",[n("code",[e._v("fallback")]),e._v(" 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 "),n("code",[e._v("Suspense")]),e._v(" 组件置于懒加载组件之上的任何位置。你甚至可以用一个 "),n("code",[e._v("Suspense")]),e._v(" 组件包裹多个懒加载组件。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { Suspense } from 'react';\n\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\nconst AnotherComponent = React.lazy(() => import('./AnotherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <section>\n          <OtherComponent />\n          <AnotherComponent />\n        </section>\n      </Suspense>\n    </div>\n  );\n}\n")])])]),n("h3",{attrs:{id:"避免兜底"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#避免兜底"}},[e._v("#")]),e._v(" 避免兜底")]),e._v(" "),n("p",[e._v("任何组件都可能因渲染而暂停，甚至是已经展示给用户的组件。为了使屏幕内容始终一致，如果一个已经显示的组件暂停，React 必须隐藏它的树，直到最近的 "),n("code",[e._v("<Suspense>")]),e._v(" 边界。然而，从用户的角度来看，这可能会使人很困惑。")]),e._v(" "),n("p",[e._v("参考这个标签切换的示例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { Suspense } from 'react';\nimport Tabs from './Tabs';\nimport Glimmer from './Glimmer';\n\nconst Comments = React.lazy(() => import('./Comments'));\nconst Photos = React.lazy(() => import('./Photos'));\n\nfunction MyComponent() {\n  const [tab, setTab] = React.useState('photos');\n  \n  function handleTabSelect(tab) {\n    setTab(tab);\n  };\n\n  return (\n    <div>\n      <Tabs onTabSelect={handleTabSelect} />\n      <Suspense fallback={<Glimmer />}>\n        {tab === 'photos' ? <Photos /> : <Comments />}\n      </Suspense>\n    </div>\n  );\n}\n")])])]),n("p",[e._v("在这个示例中，如果标签从 "),n("code",[e._v("'photos'")]),e._v(" 切换为 "),n("code",[e._v("'comments'")]),e._v("，但 "),n("code",[e._v("Comments")]),e._v(" 会暂停，用户会看到屏幕闪烁。这符合常理，因为用户不想看到 "),n("code",[e._v("'photos'")]),e._v("，而 "),n("code",[e._v("Comments")]),e._v(" 组件还没有准备好渲染其内容，而 React 为了保证用户体验的一致性，只能显示上面的 "),n("code",[e._v("Glimmer")]),e._v("，别无选择。")]),e._v(" "),n("p",[e._v("然而，有时这种用户体验并不可取。特别是在准备新 UI 时，展示 “旧” 的 UI 会体验更好。你可以尝试使用新的 "),n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-api.html#starttransition",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("startTransition")]),n("OutboundLink")],1),e._v(" API 来让 React 实现这一点：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function handleTabSelect(tab) {\n  startTransition(() => {\n    setTab(tab);\n  });\n}\n")])])]),n("p",[e._v("此处代码会告知 React，将标签切换为 "),n("code",[e._v("'comments'")]),e._v(" 不会标记为紧急更新，而是标记为需要一些准备时间的 "),n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-api.html#transitions",target:"_blank",rel:"noopener noreferrer"}},[e._v("transition"),n("OutboundLink")],1),e._v("。然后 React 会保留旧的 UI 并进行交互，当它准备好时，会切换为 "),n("code",[e._v("<Comments />")]),e._v("，具体请参阅 "),n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-api.html#transitions",target:"_blank",rel:"noopener noreferrer"}},[e._v("Transitions"),n("OutboundLink")],1),e._v(" 以了解更多相关信息。")]),e._v(" "),n("h3",{attrs:{id:"异常捕获边界-error-boundaries"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#异常捕获边界-error-boundaries"}},[e._v("#")]),e._v(" 异常捕获边界（Error boundaries）")]),e._v(" "),n("p",[e._v("如果模块加载失败（如网络问题），它会触发一个错误。你可以通过"),n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/error-boundaries.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("异常捕获边界（Error boundaries）"),n("OutboundLink")],1),e._v("技术来处理这些情况，以显示良好的用户体验并管理恢复事宜。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { Suspense } from 'react';\nimport MyErrorBoundary from './MyErrorBoundary';\n\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\nconst AnotherComponent = React.lazy(() => import('./AnotherComponent'));\n\nconst MyComponent = () => (\n  <div>\n    <MyErrorBoundary>\n      <Suspense fallback={<div>Loading...</div>}>\n        <section>\n          <OtherComponent />\n          <AnotherComponent />\n        </section>\n      </Suspense>\n    </MyErrorBoundary>\n  </div>\n);\n")])])]),n("h2",{attrs:{id:"基于路由的代码分割"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基于路由的代码分割"}},[e._v("#")]),e._v(" 基于路由的代码分割")]),e._v(" "),n("p",[e._v("决定在哪引入代码分割需要一些技巧。你需要确保选择的位置能够均匀地分割代码包而不会影响用户体验。")]),e._v(" "),n("p",[e._v("一个不错的选择是从路由开始。大多数网络用户习惯于页面之间能有个加载切换过程。你也可以选择重新渲染整个页面，这样您的用户就不必在渲染的同时再和页面上的其他元素进行交互。")]),e._v(" "),n("p",[e._v("这里是一个例子，展示如何在你的应用中使用 "),n("code",[e._v("React.lazy")]),e._v(" 和 "),n("a",{attrs:{href:"https://reactrouter.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Router"),n("OutboundLink")],1),e._v(" 这类的第三方库，来配置基于路由的代码分割。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { Suspense, lazy } from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst Home = lazy(() => import('./routes/Home'));\nconst About = lazy(() => import('./routes/About'));\n\nconst App = () => (\n  <Router>\n    <Suspense fallback={<div>Loading...</div>}>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n      </Routes>\n    </Suspense>\n  </Router>\n);\n")])])]),n("h2",{attrs:{id:"命名导出-named-exports"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#命名导出-named-exports"}},[e._v("#")]),e._v(" 命名导出（Named Exports）")]),e._v(" "),n("p",[n("code",[e._v("React.lazy")]),e._v(" 目前只支持默认导出（default exports）。如果你想被引入的模块使用命名导出（named exports），你可以创建一个中间模块，来重新导出为默认模块。这能保证 tree shaking 不会出错，并且不必引入不需要的组件。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// ManyComponents.js\nexport const MyComponent = /* ... */;\nexport const MyUnusedComponent = /* ... */;\n// MyComponent.js\nexport { MyComponent as default } from "./ManyComponents.js";\n// MyApp.js\nimport React, { lazy } from \'react\';\nconst MyComponent = lazy(() => import("./MyComponent.js"));\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);