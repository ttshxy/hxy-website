(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{398:function(v,_,e){"use strict";e.r(_);var t=e(45),l=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("一、Map和Object 的区别\n在JavaScript中，Map 和 Object 看起来都是用键值对来存储数据，那么他们有什么不同呢？")]),v._v(" "),e("p",[v._v("不同点：")]),v._v(" "),e("p",[v._v("在 Object 中， key 必须是简单数据类型（整数，字符串或者是 symbol），而在 Map 中则可以是 JavaScript 支持的所有数据类型，也就是说可以用一个 Object 来当做一个Map元素的 key。\n元素顺序：")]),v._v(" "),e("p",[v._v("Map 元素的顺序遵循插入的顺序，而 Object 的则没有这一特性。")]),v._v(" "),e("p",[v._v("Map 是"),e("strong",[v._v("可迭代对象")]),v._v("，所以其中的键值对是可以通过 "),e("code",[v._v("for of")]),v._v(" 循环或 "),e("code",[v._v(".foreach()")]),v._v(" 方法来迭代的；而普通的对象键值对则默认是不可迭代的，只能通过 "),e("code",[v._v("for in")]),v._v(" 循环来访问（或者使用 "),e("code",[v._v("Object.keys(o)、Object.values(o)、Object.entries(o)")]),v._v(" 来取得表示键或值的数字）迭代时的顺序就是上面提到的顺序。")]),v._v(" "),e("p",[e("strong",[v._v("参考答案")]),v._v("：")]),v._v(" "),e("p",[e("strong",[v._v("Set")])]),v._v(" "),e("ol",[e("li",[v._v("成员不能重复；")]),v._v(" "),e("li",[v._v("只有键值，没有键名，有点类似数组；")]),v._v(" "),e("li",[v._v("可以遍历，方法有add、delete、has")])]),v._v(" "),e("p",[e("strong",[v._v("WeakSet")])]),v._v(" "),e("ol",[e("li",[v._v("成员都是对象（引用）；")]),v._v(" "),e("li",[v._v("成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露；")]),v._v(" "),e("li",[v._v("不能遍历，方法有add、delete、has；")])]),v._v(" "),e("p",[e("strong",[v._v("Map")])]),v._v(" "),e("ol",[e("li",[v._v("本质上是键值对的集合，类似集合；")]),v._v(" "),e("li",[v._v("可以遍历，方法很多，可以跟各种数据格式转换；")])]),v._v(" "),e("p",[e("strong",[v._v("WeakMap")])]),v._v(" "),e("ol",[e("li",[v._v("只接收对象为键名（null 除外），不接受其他类型的值作为键名；")]),v._v(" "),e("li",[v._v("键名指向的对象，不计入垃圾回收机制；")]),v._v(" "),e("li",[v._v("不能遍历，方法同get、set、has、delete；")])])])}),[],!1,null,null,null);_.default=l.exports}}]);