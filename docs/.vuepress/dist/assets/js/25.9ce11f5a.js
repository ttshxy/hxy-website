(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{390:function(t,n,e){"use strict";e.r(n);var a=e(45),i=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"requestanimationframe基本使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe基本使用"}},[t._v("#")]),t._v(" requestAnimationFrame基本使用")]),t._v(" "),e("h3",{attrs:{id:"你需要知道的requestanimationframe"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#你需要知道的requestanimationframe"}},[t._v("#")]),t._v(" 你需要知道的requestAnimationFrame")]),t._v(" "),e("p",[t._v("随着前端的发展，css已经能够实现非常多的动画特效，但是仍然存在css无法完成的动画任务（比如页面滚动），通常的解决方案都是使用js中的setInterval来设置定时器来实现动画特效，比如下面的一个基本的动画循环。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("(function() {\n  function updateAnimations() {\n    doAnimation1();\n    doAnimation2();\n  }\n  setInterval(updateAnimations, 100);\n})();\n")])])]),e("p",[t._v("该代码实现的功能是每隔100毫秒执行函数操作来达到动画效果，然而，使用计时器真的可靠吗？ 答案当然是 "),e("strong",[t._v("no")])]),t._v(" "),e("p",[t._v("由于JavaScript是单线程的，所以定时器的实现是在当前任务队列完成后再执行定时器的回调的，假如当前队列任务执行时间大于定时器设置的延迟时间，那么定时器就不是那么可靠了，如下所示：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let startTime = new Date().getTime();\nsetTimeout(()=>{\n  let endTime = new Date().getTime();\n  console.log(endTime - startTime);\n},50)\n\nfor(let i=0;i<20000;i++) {\n  console.log(1);\n}\n")])])]),e("p",[t._v("输出如下")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/13/1618f7bc6acd9f5c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"示例"}})]),t._v(" "),e("p",[t._v("可以看到，设置了50毫秒后执行，实际执行延迟时间远大于这个数值，这就会导致动画效果并不会达到想要的效果。")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("动画是由浏览器按照一定的频率一帧一帧的绘制的，由css实现的动画的优势就是浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新UI，给用户一种流畅的体验，而setInterval或setTimeout实现的JavaScript动画就没有这么可靠了，因为浏览器压根就无法保证每一帧渲染的时间间隔，一般情况下，每秒平均刷新次数能够达到60帧，就能够给人流畅的体验，即每过 1000/60 毫秒渲染新一帧即可，但从上面的例子知，这一点单靠定时器是无法保证的。 为此，requestAnimationFrame应运而生，其作用就是让浏览器流畅的执行动画效果。可以将其理解为专门用来实现动画效果的api，通过这个api,可以告诉浏览器某个JavaScript代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了。")]),t._v(" "),e("p",[t._v("使用方法如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n    <style type="text/css">\n      #box {\n        width: 100px;\n        height: 40px;\n        background-color: green;\n      }\n    </style>\n    <script>\n      function animationWidth() {\n        var div = document.getElementById(\'box\');\n        div.style.width = parseInt(div.clientWidth) + 1 + \'px\';\n        if (parseInt(div.style.width) < 200) {\n          requestAnimationFrame(animationWidth);\n        }\n      }\n      function clickFun() {\n        animationWidth();\n      }\n    <\/script>\n  </head>\n  <body>\n    <div id="box"></div>\n    <button onclick="clickFun()">开始动画</button>\n  </body>\n</html>\n')])])]),e("p",[t._v("效果如下(GIF录制的有点卡。。。实际效果请参考"),e("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fzhaolyang.github.io%2FblogBlogBlog%2Fjavascript%2FrequestAnimationFrame%2Fdemo.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("示例"),e("OutboundLink")],1),t._v(")：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/13/1618f7bc6acd9f5c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"示例"}})]),t._v(" "),e("p",[e("strong",[t._v("requestAnimationFrame做了一部分性能优化，比如浏览器切换Tab时动画会停止")])]),t._v(" "),e("p",[t._v("可以看到，requestAnimationFrame接受一个动画执行函数作为参数，这个函数的作用是仅执行一帧动画的渲染，并根据条件判断是否结束，如果动画没有结束，则继续调用requestAnimationFrame并将自身作为参数传入。从示例来看，得到了效果平滑流畅的动画，这样就巧妙地避开了每一帧动画渲染的时间间隔问题。")]),t._v(" "),e("p",[t._v("requestAnimationFrame的兼容性参考"),e("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fcaniuse.com%2F%23search%3DrequestAnimationFrame",target:"_blank",rel:"noopener noreferrer"}},[t._v("caniuse"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("在高级浏览器中，开发人员不用去操心每一帧动画渲染的时间间隔问题，而针对低版本浏览器，则需要使用setTimeout来模拟requestAnimationFrame,且针对不同浏览器对requestAnimationFrame的实现，这个api的名字也略有差异，针对低版本浏览器的模拟requestAnimationFrame的写法如下(来自张鑫旭大神的博客)：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("(function() {\n    var lastTime = 0;\n    var vendors = ['webkit', 'moz'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||    // Webkit中此取消方法的名字变了\n                                      window[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n\n    if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));\n            var id = window.setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n    if (!window.cancelAnimationFrame) {\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n    }\n}());\n复制代码\n")])])]),e("p",[t._v("具体含义不做解释，如果遇到低版本浏览器的动画需求，你只需要把这段代码丢进去定义一个低配版requestAnimationFrame方法即可（珍爱生命，远离老浏览器啊）。")])])}),[],!1,null,null,null);n.default=i.exports}}]);